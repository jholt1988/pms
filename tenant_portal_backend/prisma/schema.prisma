
// This is your Prisma schema file,
// learn more about it in the docs: https://pris.ly/d/prisma-schema

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model User {
  id             Int      @id @default(autoincrement())
  username       String   @unique
  password       String
  role           Role     @default(TENANT)
  failedLoginAttempts Int @default(0)
  lockoutUntil   DateTime?
  mfaEnabled     Boolean @default(false)
  mfaSecret      String?
  mfaTempSecret  String?
  passwordUpdatedAt DateTime @default(now())
  lastLoginAt    DateTime?
  requests       MaintenanceRequest[]
  lease          Lease?
  payments       Payment[]
  conversations  ConversationParticipant[]
  sentMessages   Message[] @relation("sentMessages")
  rentalApplications RentalApplication[]
  expenses       Expense[] @relation("RecordedExpenses")
  paymentMethods PaymentMethod[]
  screenedApplications RentalApplication[] @relation("ScreenedApplications")
  applicationNotes RentalApplicationNote[]
  securityEvents SecurityEvent[]
}

model Property {
  id      Int    @id @default(autoincrement())
  name    String
  address String
  units   Unit[]
  rentalApplications RentalApplication[]
  expenses Expense[]
}

model Unit {
  id         Int      @id @default(autoincrement())
  name       String // e.g., "Apt 101"
  property   Property @relation(fields: [propertyId], references: [id])
  propertyId Int
  lease      Lease?
  rentalApplications RentalApplication[]
  expenses   Expense[]
}

model Lease {
  id          Int      @id @default(autoincrement())
  startDate   DateTime
  endDate     DateTime
  rentAmount  Float
  tenant      User     @relation(fields: [tenantId], references: [id])
  tenantId    Int      @unique // A user can only have one lease
  unit        Unit     @relation(fields: [unitId], references: [id])
  unitId      Int      @unique // A unit can only have one lease
  payments    Payment[]
  invoices    Invoice[]
  recurringSchedule RecurringInvoiceSchedule?
  autopayEnrollment AutopayEnrollment?
}

model MaintenanceRequest {
  id          Int      @id @default(autoincrement())
  title       String
  description String
  status      Status   @default(PENDING)
  author      User     @relation(fields: [authorId], references: [id])
  authorId    Int
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt
  priority    MaintenancePriority @default(MEDIUM)
  dueAt       DateTime?
  acknowledgedAt DateTime?
  completedAt DateTime?
  property    Property? @relation(fields: [propertyId], references: [id])
  propertyId  Int?
  unit        Unit? @relation(fields: [unitId], references: [id])
  unitId      Int?
  asset       MaintenanceAsset? @relation(fields: [assetId], references: [id])
  assetId     Int?
  assignee    Technician? @relation(fields: [assigneeId], references: [id])
  assigneeId  Int?
  history     MaintenanceRequestHistory[]
  notes       MaintenanceNote[]
  photos      MaintenancePhoto[]
}

model Invoice {
  id        Int      @id @default(autoincrement())
  description String
  amount    Float
  dueDate   DateTime
  status    String   @default("UNPAID") // UNPAID, PAID, OVERDUE
  lease     Lease    @relation(fields: [leaseId], references: [id])
  leaseId   Int
  payments  Payment[]
  issuedAt  DateTime @default(now())
  externalId String? @unique
  lateFees  LateFee[]
  schedule   RecurringInvoiceSchedule? @relation(fields: [scheduleId], references: [id])
  scheduleId Int?
}

model Payment {
  id        Int      @id @default(autoincrement())
  amount    Float
  paymentDate      DateTime @default(now())
  status    String // e.g., "COMPLETED", "FAILED"
  invoice   Invoice?  @relation(fields: [invoiceId], references: [id])
  invoiceId Int?
  user      User     @relation(fields: [userId], references: [id])
  userId    Int
  lease     Lease?    @relation(fields: [leaseId], references: [id])
  leaseId   Int?
  externalId String? @unique
  reconciledAt DateTime?
  paymentMethod PaymentMethod? @relation(fields: [paymentMethodId], references: [id])
  paymentMethodId Int?
}

model Conversation {
  id           Int      @id @default(autoincrement())
  participants ConversationParticipant[]
  messages     Message[]
  createdAt    DateTime @default(now())
  updatedAt    DateTime @updatedAt
}

model ConversationParticipant {
  user           User         @relation(fields: [userId], references: [id])
  userId         Int
  conversation   Conversation @relation(fields: [conversationId], references: [id])
  conversationId Int

  @@id([userId, conversationId])
}

model Message {
  id             Int      @id @default(autoincrement())
  content        String
  sender         User     @relation("sentMessages", fields: [senderId], references: [id])
  senderId       Int
  conversation   Conversation @relation(fields: [conversationId], references: [id])
  conversationId Int
  createdAt      DateTime @default(now())
}

model RentalApplication {
  id                 Int                @id @default(autoincrement())
  applicant          User?              @relation(fields: [applicantId], references: [id])
  applicantId        Int?
  property           Property           @relation(fields: [propertyId], references: [id])
  propertyId         Int
  unit               Unit               @relation(fields: [unitId], references: [id])
  unitId             Int
  status             ApplicationStatus  @default(PENDING)
  applicationDate    DateTime           @default(now())
  fullName           String
  email              String
  phoneNumber        String
  income             Float
  employmentStatus   String
  previousAddress    String
  creditScore        Int?
  monthlyDebt        Float?
  bankruptcyFiledYear Int?
  rentalHistoryComments String?
  qualificationStatus QualificationStatus? // Added for screening
  recommendation     Recommendation?    // Added for screening
  screeningDetails   String?            // Added for screening
  screeningScore     Float?
  screeningReasons   Json?
  screenedAt         DateTime?
  screenedBy         User?              @relation("ScreenedApplications", fields: [screenedById], references: [id])
  screenedById       Int?
  manualNotes        RentalApplicationNote[]
  createdAt          DateTime           @default(now())
  updatedAt          DateTime           @updatedAt
}

model Expense {
  id          Int            @id @default(autoincrement())
  property    Property       @relation(fields: [propertyId], references: [id])
  propertyId  Int
  unit        Unit?          @relation(fields: [unitId], references: [id])
  unitId      Int?
  description String
  amount      Float
  date        DateTime
  category    ExpenseCategory
  recordedBy  User           @relation("RecordedExpenses", fields: [recordedById], references: [id])
  recordedById Int
  createdAt   DateTime       @default(now())
  updatedAt   DateTime       @updatedAt
}

enum Status {
  PENDING
  IN_PROGRESS
  COMPLETED
}

enum Role {
  TENANT
  PROPERTY_MANAGER
}

enum ApplicationStatus {
  PENDING
  APPROVED
  REJECTED
}

enum QualificationStatus {
  QUALIFIED
  NOT_QUALIFIED
}

enum Recommendation {
  RECOMMEND_RENT
  DO_NOT_RECOMMEND_RENT
}

model RentalApplicationNote {
  id          Int                @id @default(autoincrement())
  application RentalApplication  @relation(fields: [applicationId], references: [id])
  applicationId Int
  author      User?              @relation(fields: [authorId], references: [id])
  authorId    Int?
  body        String
  createdAt   DateTime           @default(now())

  @@index([applicationId])
}

enum ExpenseCategory {
  MAINTENANCE
  UTILITIES
  TAXES
  INSURANCE
  REPAIRS
  OTHER
}

model PaymentMethod {
  id           Int                 @id @default(autoincrement())
  user         User                @relation(fields: [userId], references: [id])
  userId       Int
  type         PaymentMethodType
  provider     PaymentProvider
  providerCustomerId String?
  providerPaymentMethodId String?
  last4        String?
  brand        String?
  expMonth     Int?
  expYear      Int?
  createdAt    DateTime            @default(now())
  updatedAt    DateTime            @updatedAt
  autopayEnrollments AutopayEnrollment[]
  payments     Payment[]
}

enum PaymentMethodType {
  CARD
  BANK_ACCOUNT
}

enum PaymentProvider {
  STRIPE
  PLAID
  OTHER
}

model RecurringInvoiceSchedule {
  id           Int      @id @default(autoincrement())
  lease        Lease    @relation(fields: [leaseId], references: [id])
  leaseId      Int      @unique
  amount       Float
  description  String   @default("Monthly Rent")
  frequency    BillingFrequency @default(MONTHLY)
  dayOfMonth   Int?     // required for monthly
  dayOfWeek    Int?     // optional for weekly
  nextRun      DateTime
  lateFeeAmount Float?  // flat fee
  lateFeeAfterDays Int? // number of days after due date
  active       Boolean  @default(true)
  createdAt    DateTime @default(now())
  updatedAt    DateTime @updatedAt
  invoices     Invoice[]
}

enum BillingFrequency {
  MONTHLY
  WEEKLY
}

model LateFee {
  id         Int      @id @default(autoincrement())
  invoice    Invoice  @relation(fields: [invoiceId], references: [id])
  invoiceId  Int
  amount     Float
  assessedAt DateTime @default(now())
  waived     Boolean  @default(false)
}

model AutopayEnrollment {
  id            Int             @id @default(autoincrement())
  lease         Lease           @relation(fields: [leaseId], references: [id])
  leaseId       Int             @unique
  paymentMethod PaymentMethod   @relation(fields: [paymentMethodId], references: [id])
  paymentMethodId Int
  active        Boolean         @default(true)
  maxAmount     Float?
  createdAt     DateTime        @default(now())
  updatedAt     DateTime        @updatedAt
}

model SecurityEvent {
  id        Int      @id @default(autoincrement())
  user      User?    @relation(fields: [userId], references: [id])
  userId    Int?
  username  String?
  type      SecurityEventType
  success   Boolean
  ipAddress String?
  userAgent String?
  metadata  Json?
  createdAt DateTime @default(now())

  @@index([createdAt])
  @@index([type])
}

enum SecurityEventType {
  LOGIN_SUCCESS
  LOGIN_FAILURE
  LOGIN_LOCKED
  PASSWORD_CHANGED
  MFA_ENROLLMENT_STARTED
  MFA_ENABLED
  MFA_DISABLED
  MFA_CHALLENGE_FAILED
  AUTOPAY_ENABLED
  AUTOPAY_DISABLED
  RECURRING_BILLING_UPDATED
  APPLICATION_SCREENED
  APPLICATION_NOTE_CREATED
}





